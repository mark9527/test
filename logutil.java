package com.hsbc.rbwm.digital.amh.base;
import java.io.PrintWriter;import java.io.StringWriter;
import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.util.StringUtils;
public class LoggingUtil { static final String NEW_LINE = "\r\n"; static String NEW_LINE_REPLACE = null; private static final String EMPTY = ""; private static final String ENTRY = "entry"; private static final String EXIT = "exit"; private static final String INPUT_ARG = "inputArg"; private static final String OUTPUT_ARG = "outputArg"; private static final String ARG_2 = "{} - {}"; private static final String ARG_3 = "{} - {} - {}"; private static final String ARG_4 = "{} - {} - {} - {}"; private static final String ARG_5 = "{} - {} - {} - {} - {}";  private static final String ARG_INPUT = "{} - {} - {}{}/{} - {}";  private static final String SEPARATOR = "--##--"; private static final int SEPARATOR_LENGTH = SEPARATOR.length() + 1;  /**  * Get the stack trace from a throwable and convert it into a String.  *   * If the BaseException is an NestableException, the stack trace from   * the root cause will append at the end.  *   * @param throwable  * @return  */ public static String getStackTrace(Throwable throwable) {   StringWriter sw = new StringWriter();  PrintWriter pw = new PrintWriter(sw);    throwable.printStackTrace(pw);  if (NEW_LINE_REPLACE != null) {    return sw.toString().replace(NEW_LINE, NEW_LINE_REPLACE);  }  return sw.toString(); }
 /**  * Log the debug message using the ES <code>Debugger</code>.  *   * @param className  * @param methodName  * @param mesg  */ public static void logDebug(String className, String methodName, String msg) {  final Logger DEBUGGER = LoggerFactory.getLogger(className);  if (DEBUGGER.isDebugEnabled()) {     DEBUGGER.debug(ARG_2, new Object[]{methodName, msg});  } }
 /**  * Log the debug message using the ES <code>Debugger</code>.  *   * @param className  * @param methodName  * @param mesg  */ public static void logDebug(String className, String methodName, String msg, Object... obj) {  final Logger DEBUGGER = LoggerFactory.getLogger(className);  if (DEBUGGER.isDebugEnabled()) {   DEBUGGER.debug(ARG_3, new Object[]{methodName, msg, String.format(SEPARATOR, obj)});  } }
  /**  * Log the method entry using the ES <code>Debugger</code>.  *   * @param className  * @param methodName  */ public static void logEntry(String className, String methodName) {    logEntry(className, methodName, ENTRY); }
 /**  * Log the method entry with output argument(s) using the ES <code>Debugger</code>.  *   * @param className  * @param methodName  * @param inputArgs  */ public static void logEntry(String className, String methodName, Object inputArg) {  final Logger DEBUGGER = LoggerFactory.getLogger(className);  if (DEBUGGER.isDebugEnabled()) {     DEBUGGER.debug(ARG_4, new Object[]{methodName, ENTRY, INPUT_ARG, inputArg});  } } /**  * Log the method entry with output argument(s) using the ES <code>Debugger</code>.  *   * @param className  * @param methodName  * @param inputArgs  */ public static void logEntry(String className, String methodName, Object... inputArg) {  final Logger DEBUGGER = LoggerFactory.getLogger(className);  if (DEBUGGER.isDebugEnabled()) {   int totalArg = inputArg.length;   for (int i = 0; i < totalArg; i++) {    DEBUGGER.debug(ARG_INPUT, new Object[]{methodName, ENTRY, INPUT_ARG, i+1, totalArg, inputArg[i]});   }  } } /**  * Log the method entry with output argument(s) using the ES <code>Debugger</code>.  *   * @param className  * @param methodName  * @param inputArgNames  * @param inputArgs  */
 public static void logEntry(String className, String methodName, String[] inputArgNames, Object[] inputArgs) {  final Logger DEBUGGER = LoggerFactory.getLogger(className);    if (DEBUGGER.isDebugEnabled()) {     if (inputArgs != null && inputArgs.length > 0) {       for (int i=0; i<inputArgs.length; ++i) {     String argName = null;         if (inputArgNames != null && inputArgNames.length > i) {      argName = inputArgNames[i];     }         if (StringUtils.isEmpty(argName)) {      argName = EMPTY;     }         DEBUGGER.debug(ARG_5, methodName, ENTRY, INPUT_ARG, argName, inputArgs[i]);    }   }  } }
 /**  * Log the exception stack trace using the ES <code>ErrorRecorder</code>.  *   * @param className  * @param methodName  * @param throwable  */ public static void logError(String className, String methodName, String msg) {   logError(className, methodName, msg, (String) null); }
 /**  * Log the error message using the ES <code>ErrorRecorder</code>.  *   * @param className  * @param methodName  * @param mesg  */ public static void logError(String className, String methodName, String msg1, String msg2) {   final Logger ERROR_RECORDER = LoggerFactory.getLogger(className);  if (msg2 != null) {   ERROR_RECORDER.error(ARG_3, new Object[]{methodName, msg1, msg2});  } else {   ERROR_RECORDER.error(ARG_2, new Object[]{methodName, msg1});  } }
 /**  * Log the exception stack trace using the ES <code>ErrorRecorder</code>.  *   * @param className  * @param methodName  * @param throwable  */ public static void logError(String className, String methodName, String msg, Throwable throwable) {   String stackTrace = getStackTrace(throwable);  logError(className, methodName, msg, stackTrace); }
 /**  * Log the method exit using the ES <code>Debugger</code>.  *   * @param className  * @param methodName  */ public static void logExit(String className, String methodName) {    final Logger DEBUGGER = LoggerFactory.getLogger(className);    if (DEBUGGER.isDebugEnabled()) {   DEBUGGER.debug(ARG_2, new Object[]{methodName, EXIT});  } } 
 /**  * Log the method exit with output argument using the ES <code>Debugger</code>.  *   * @param className  * @param methodName  * @param outputArgName  * @param outputArg  */ public static void logExit(String className, String methodName, Object outputArg) {  final Logger DEBUGGER = LoggerFactory.getLogger(className);    if (DEBUGGER.isDebugEnabled()) {   DEBUGGER.debug(ARG_4, new Object[]{methodName, EXIT, OUTPUT_ARG, outputArg});  } }  /**  * Log the information message using the ES <code>Auditor</code>.  *   * @param className  * @param methodName  * @param msg  */ public static void logInfo(String className, String methodName, Object... msg) {  final Logger AUDITOR = LoggerFactory.getLogger(className);    if (AUDITOR.isInfoEnabled()) {   StringBuilder sb = new StringBuilder();   for (Object obj : msg) {    sb.append(obj).append(SEPARATOR);   }   sb.setLength(sb.length()-SEPARATOR_LENGTH);   AUDITOR.info(ARG_2, new Object[]{methodName, sb.toString()});  } }  /**  * Log the information message using the ES <code>Auditor</code>.  *   * @param className  * @param methodName  * @param msg  */ public static void logInfo(String className, Object... msg) {  final Logger AUDITOR = LoggerFactory.getLogger(className);    if (AUDITOR.isInfoEnabled()) {   StringBuilder sb = new StringBuilder();   for (Object obj : msg) {    sb.append(obj).append(SEPARATOR);   }   sb.setLength(sb.length()-SEPARATOR_LENGTH);   AUDITOR.info(sb.toString());  } }  /**  * Log the debug message using the ES <code>Debugger</code>.  *   * @param className  * @param methodName  * @param mesg  */ public static void logWarn(String className, String methodName, String msg) {  final Logger WARN = LoggerFactory.getLogger(className);  if (WARN.isWarnEnabled()) {     WARN.warn(ARG_2, new Object[]{methodName, msg});  } }
 public static void setReplaceNewLine(String newLine) {  NEW_LINE_REPLACE = newLine; }}
